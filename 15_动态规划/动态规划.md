## 动态规划

一道动态规划题目的标准题解：

1. 设定一个值作为最优解，比如[LC322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)，设定dp[i]表示凑成金额i所需要的最少硬币数
2. 确定转移方程
3. 检查边界、目标
4. 一道动态规划题目，写出状态转移方程就已经完成大半的工作，剩下的任务就是照着方程写几层循环递推实现就行了

动规三要素：阶段、状态、决策

先for状态，再for决策

把最优化的目标放到状态的值里面，也就是dp[i] [j]的值

### 动态规划解题步骤

1. 人力模拟/蛮力搜索，从1->2要关注“轮廓变化”
2. 定义状态，要关注它们之间的推导关系
3. 确定最优子结构
4. 写出状态转移方程，要关注人力模拟时作出的决策，每一次决策就是一次状态转移
5. 确定边界、目标，递推实现，边界包括：起点、会访问到的不合法状态

### 动态规划打印方案

动态规划打印方案的原则：**记录转移路径 + 递归输出**

动态规划选取“代表”，维护了一个最优子结构

如果记录每个最优子结构的详细方案，时间复杂度会上升

以LCS为例，本来是O(${len}^2$)，每个opt[i, j]记录一个方案（字符串），就变成了O(${len}^3$)

正确做法：

> 记录每个f[i, j]是从哪里转移过来的（${f[i - 1][j]}$, $f[i][j - 1]$ 还是$f[i - 1][j - 1]$
>
> 整个动规完成，求出$f[n, m]$后，再从(n, m)开始递归复原最优路径



### 股票系列题目的思考

#### 思考一：动态规划与贪心的对比

无交易次数限制，可贪心

* 当前持有股票，卖不卖？往后看一天，明天还涨那肯定不卖，明天跌那肯定卖啊！
  ——往后看一天就知道今天怎么操作，局部最优可推出全局最优

有交易k次限制，不能贪心

* “明天跌那肯定卖啊”这个策略不再正确，也许明天小幅回调，后天继续大涨，卖出将会消耗
  次交易机会，可能导致后续无法再交易
  ——往后看到底才有可能知道今天怎么操作，決策是基于全局考量的

从这里可以看出，**贪心题都能用动态规划做**，只不过时间复杂度会差一些

拿到题目后思考的顺序如下：

**蛮力搜索（寻找同类子问题）➡️分治（寻找最优子结构）➡️动态规划**

#### 思考二：动态规划中状态与决策的平衡选择

状态包含的信息越多就，决策越简单；状态越简单，决策越复杂

一般解题时，尽量把人工模拟时关注的信息都放到状态里，除非最后状态规模太大再考虑简化

#### 思考三：状态转移方程的两种写法

在一些決策比较复杂的题目中，考虑“$f[i][j][k][l]$该怎么计算？”会比较难，这种思考就是在考虑入边

其实状态转移还有另外一种考虑方式：“$f[i][j][k][l]$能更新哪些状态?”，这种思考就是在考虑出边

DP的本质还是对状态空间的遍历，这两个的区别就像“谁能走到我”和“我能走到谁”

可以自由选择，哪个想起来比较顺，就用哪个

> 同时，如果状态转移方程不好写，可以用列表法，直接写出来所有的转移方式，利于思考

#### 思考四：空间的优化

观察状态转移方程，如果$f[i][j][k][l]$总是从状态$f[i - 1][j][k][l]$转移过来，与更早的状态没有关系

那么状态的转移就可以看作是相邻两行之间的互相转化

那么就可以考虑使用**滚动数组**优化，即使用时在每一个$f$的第一维加一个&1（and 1，即mod2），同时要注意初始化复用的空间 

### 区间DP

先枚举区间长度

### 树形DP

与线性DP没有本质区别，只是在深度搜索优先遍历里的动态规划（即在DFS的过程中实现DP）

子问题就是“一颗子树”，状态一般表示为“以x为根的子树”，决策就是“x的子节点“